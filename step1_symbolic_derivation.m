% STEP 1: SYMBOLIC DERIVATION OF PREDICTIVE CODING UPDATE RULES
% ================================================================
% This script derives the mathematical update rules for a two-level
% hierarchical generative model using symbolic computation.
%
% THEORY:
% In predictive coding, the brain is modeled as a hierarchical system
% that minimizes prediction errors. Each level tries to predict the
% level below it, and updates beliefs when predictions are wrong.
%
% Level 2: Velocity (hidden cause) → predicts → Level 1: Position
% Level 3: Prior belief → constrains → Level 2: Velocity
%
% The system minimizes "Free Energy" F, which is the weighted sum of
% squared prediction errors (similar to least squares optimization).

clear; clc;
fprintf('=== STEP 1: SYMBOLIC DERIVATION ===\n\n');

%% Define Symbolic Variables
syms x v real                      % x = position, v = velocity (state variables)
syms x_obs real                    % x_obs = sensory observation
syms mu_v sigma_x sigma_v real     % hyperparameters (priors)
syms dt real positive              % time step

% Assume all are real and positive where appropriate
assume(sigma_x > 0);
assume(sigma_v > 0);

fprintf('Symbolic variables defined:\n');
fprintf('  x       = estimated position\n');
fprintf('  v       = estimated velocity (hidden state)\n');
fprintf('  x_obs   = observed sensory input\n');
fprintf('  mu_v    = prior mean for velocity\n');
fprintf('  sigma_x = sensory precision (noise level)\n');
fprintf('  sigma_v = prior precision on velocity\n\n');

%% Define Hierarchical Generative Model
fprintf('GENERATIVE MODEL (How the world works):\n');
fprintf('  Level 2 → Level 1: Position is generated by velocity\n');
fprintf('  In continuous time: dx/dt = v\n');
fprintf('  Prediction: x_pred = v (velocity predicts position rate)\n\n');

% Level 1: Position is predicted by velocity
x_pred = v;  % simplified: in continuous time, velocity generates position change

% Level 2: Velocity has a Gaussian prior centered at mu_v
v_pred = mu_v;  % expected velocity (could be 0 for stationary prior)

fprintf('  Level 3 → Level 2: Velocity prior centered at mu_v = %.1f\n\n', 0);

%% Compute Prediction Errors
fprintf('PREDICTION ERRORS (Surprise signals):\n');

% Sensory prediction error (how wrong is our position estimate?)
epsilon_x = x_obs - x_pred;
fprintf('  ε_x = x_obs - v  (sensory surprise)\n');

% Prior prediction error (how far is velocity from prior?)
epsilon_v = v - v_pred;
fprintf('  ε_v = v - mu_v   (prior surprise)\n\n');

%% Free Energy Functional
fprintf('FREE ENERGY (Objective to minimize):\n');
fprintf('  F = (1/2) * [ε_x²/σ_x² + ε_v²/σ_v²]\n');
fprintf('  This is the negative log posterior probability.\n');
fprintf('  Smaller F = better model of the world.\n\n');

% Free energy (negative log posterior)
F = (epsilon_x^2)/(2*sigma_x^2) + (epsilon_v^2)/(2*sigma_v^2);

% Display in pretty format
fprintf('Expanded form:\n');
pretty(F)
fprintf('\n');

%% Derive Update Rules via Gradient Descent
fprintf('GRADIENT DESCENT UPDATE RULES:\n');
fprintf('  The system minimizes F by gradient descent:\n');
fprintf('  dx/dt = -∂F/∂x\n');
fprintf('  dv/dt = -∂F/∂v\n\n');

% For position (perceptual inference)
% Note: we differentiate w.r.t. x_pred to get perceptual dynamics
dx_dt = -diff(F, x_pred);

% For velocity (belief update)
dv_dt = -diff(F, v);

% Simplify the expressions
dx_dt = simplify(dx_dt);
dv_dt = simplify(dv_dt);

fprintf('Perceptual dynamics (position update):\n');
fprintf('  dx/dt = ');
pretty(dx_dt)
fprintf('\n');

fprintf('Belief dynamics (velocity update):\n');
fprintf('  dv/dt = ');
pretty(dv_dt)
fprintf('\n');

%% Interpretation
fprintf('INTERPRETATION:\n');
fprintf('  dx/dt: Position estimate is pulled toward observation\n');
fprintf('         Strength depends on sensory precision (1/σ_x²)\n\n');

fprintf('  dv/dt: Velocity is updated by TWO forces:\n');
fprintf('         1) Sensory prediction error (bottom-up)\n');
fprintf('         2) Prior expectation (top-down)\n');
fprintf('         Balance depends on σ_x and σ_v\n\n');

%% Numerical Forms
fprintf('For numerical simulation, these become:\n');
fprintf('  dx/dt = (x_obs - v) / σ_x²\n');
fprintf('  dv/dt = (x_obs - v) / σ_x² - (v - mu_v) / σ_v²\n\n');

%% Save for Later Use
fprintf('Saving symbolic expressions to workspace...\n');
save('symbolic_derivations.mat', 'dx_dt', 'dv_dt', 'F', 'epsilon_x', 'epsilon_v');

fprintf('\n=== STEP 1 COMPLETE ===\n');
fprintf('Next: Run step2_numerical_simulation.m to simulate these dynamics.\n');
