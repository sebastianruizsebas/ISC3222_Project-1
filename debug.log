[Warning: Name is nonexistent or not a directory: C:\Users\srseb\OneDrive\School\FSU\Fall 2025\Symbolic Numeric Computation w Alan Lemmon\Project1\activeinferencetutorial] 
╔═════════════════════════════════════════════════════════════╗
║  SENSORIMOTOR LEARNING: 3D REACHING & GRASPING             ║
║  Learning to Reach Targets in 3D Space via Predictive Coding ║
╚═════════════════════════════════════════════════════════════╝

Batch mode: Graphics output disabled, figures will be saved to disk.

3D REACHING TASK (Multi-Trial):
Workspace bounds: X∈[-2.00,2.00], Y∈[-2.00,2.00], Z∈[-1.00,2.00]

Trial 1 (0.00-39.99s): Start [-0.50, 1.80, 1.20] → Target [1.50, 1.50, 1.00]
Trial 2 (40.00-79.99s): Start [0.39, -1.38, -0.53] → Target [-1.50, 1.50, 0.50]
Trial 3 (80.00-119.99s): Start [-1.77, 1.46, 0.80] → Target [-1.50, -1.50, 1.50]
Trial 4 (120.00-159.99s): Start [0.83, -1.92, 1.91] → Target [1.50, -1.50, -0.50]

3D REACHING TASK:
  Phase 1 (0-40.00s):  Reach to target [1.50, 1.50, 1.00]
  Phase 2 (40.00-80.00s):  Reach to target [-1.50, 1.50, 0.50]
  Phase 3 (80.00-120.00s):  Reach to target [-1.50, -1.50, 1.50]
  Phase 4 (120.00-160.00s): Reach to target [1.50, -1.50, -0.50]

NETWORK ARCHITECTURE (3D SENSORIMOTOR):
  Level 1 (Proprioception): 7 neurons [x, y, z, vx, vy, vz, bias]
    → Inferred from arm position and velocity in 3D
  Level 2 (Motor Basis):    6 neurons [learned motor primitives]
    → Learned combinations of 3D velocity commands
  Level 3 (Goal):           4 neurons [target_x, target_y, target_z, bias]

    → Represents desired 3D location (provided by task)

3D MOTOR DYNAMICS:
  Motor gain: 0.50 (scaling of commands to actual motion)
  Damping: 0.95 (velocity decay per timestep)
  Workspace: x,y,z ∈ [-2.00, 2.00] meters

LEARNING PARAMETERS:
  η_rep = 0.005000 (representation learning rate)
  η_W   = 0.000500 (weight matrix learning rate)
  Momentum = 0.9000
  Weight Decay = 0.9800
  π_L1  = 100, π_L2  = 10, π_L3  = 1

HIERARCHICAL PREDICTIVE CODING WITH ACTIVE INFERENCE:
─────────────────────────────────────────────────────────────
L3 (Goal): ACTIVE INFERENCE NODE
  • NOT clamped to task target (varies over time)
  • Infers goal from proprioceptive errors (bottom-up)
  • Pulled toward task target by soft constraint (top-down)
  • Creates continuous prediction errors for learning
  • Enables generalization across phase transitions

L2 (Motor Basis): Learned motor primitives
  • Learns to predict motor commands from goal
  • Updated via proprioceptive coupling errors

L1 (Proprioception): Sensory prediction layer
  • Predicts position and velocity from motor commands
  • Compared against actual sensory input
  • Generates error signals that drive learning
  η_W   = 0.000500 (weight matrix learning rate)
  Momentum = 0.9000
  Weight Decay = 0.9800
  π_L1  = 100, π_L2  = 10, π_L3  = 1

INITIAL CONDITIONS (Trial 1):
  Start position: [-0.50, 1.80, 1.20]
  Target position: [1.50, 1.50, 1.00]
  R_L2(1,:) = reaching velocity [0.4004, -0.0606, -0.0392] m/s (toward target)
  R_L3(1,:) = [target_x=1.50, target_y=1.50, target_z=1.00, bias=1]

WEIGHT MATRICES INITIALIZED (Bootstrapped):
  W_L2_from_L3: Goal → Motor (target position → velocity commands)
    - Direct coupling: target_xyz → motor velocity (gain=0.1)
    - Auxiliary channels: random small values
  W_L1_from_L2: Motor → Proprioception
    - Direct coupling: motor velocity → predicted velocity (gain=1.0)
    - Position predictions: weak coupling (gain=0.01)

Running 3D sensorimotor reaching trials...
Total iterations: 16000 (dt=0.0100s per step, ~160.0 seconds estimated)
........................................
[Trial 2 started at step 4001 - WEIGHT DECAY]
  W_L2_from_L3: ||W|| 1.638906 → 0.819453 (decay: 50.0%)
  W_L1_from_L2: ||W|| 0.143708 → 0.100595 (decay: 30.0%)
  L2 reinitialized: R_L2(i,1:3) = [-0.3789, 0.5752, 0.2064] (reaching speed 0.7190 m/s)
{Index in position 1 exceeds array bounds. Index must not exceed 1.

Error in hierarchical_motion_inference_3D_EXACT (line 358)
    if current_trial > 1 && i >= phases_indices(current_trial, 1) && i <= phases_indices(current_trial, 1) + 4
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
} 
